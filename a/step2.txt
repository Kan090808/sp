//variable
program started;
program ended;
program line number;
program error number;
program name;
program starting address;
program ending address;
now address;
assembler directives list;
optable;
symbol table;
output table;

//read optable
read line from opcode file;
while(line not null) {//read until empty line
	add mnemonic and opcode to optable;
}
read end;

//read line from program file;
while(line not null){
	cut by space;
	add mnemonic and opcode to optable;
}

while(prog not end){
	record program line number;
	
	//delete all comments
	if(line not null && contains "."){
		cut line by ".";
		if(cut success)//array length > 0
			replace line by string before ".";
		else
			line is only ".";
	}
	
	//line without comments
	if(line not null){
		if(line has words){//do nothing when line only has space and tab
			line to uppercase;
			cut line by all space and tab;
			if(has 4 token){
				combine third and fourth token;
			}
			if(token not more than 3){
				if(program not started){
					if(has 3 token){
						if(second token is "START"){
							if(third token is 16 digits)){
								first token is program name;
								third token is program starting address;
								record program starting address as this line address;
								record first as this line label
								record second token as mnemonic;
								record third as this line operand;
								record line number as this line number;
								record this line opcode by empty; 
								record this line symbol code by empty;
								add this line into output table; 
								record program started;;
							}else{
								error number added;
								show error:only allow 16 digits behind "START";
								break;
							}
						}
					}else if(has 2 token){
						if(second token is "START"){
							error number added;
							show error:no starting address;
							break;
						}else if(first token is "START"){
							error number added;
							show error:no progname;
							break;
						}
					}else{//has 1 token
						if(first token is "START")){
							error number added++;
							show error:no progname and starting address;
							break;
						}
					}
				}else if(program started){
					record now address as this line address;
					record now line number as this line number;
					if(has 1 token){
						if(first token is "RSUB"){
							record first token as this line mnemonic;
							record "4C" as this line opcode;
							record "0000" as this line symbol code;
							add this line into ouput table;
							current address+3;
						}else if(first token is mnemonic or notmne){//notmne = {"BYTE", "RESB", "WORD", "RESW"};
							error number added;
							show error:no operand;
						}else if(first token is "END"){
							record program ended;
							error number added;
							show error:no prog first line address;
						}else{
							error number added;
							show error:format wrong;
						}
					}else if(has 2 token) {
						if(first token is "RSUB"){
							record "4C" as this line opcode;
							record "0000" as this line symbol code;
							if(second token not space and tab){
								error number added;
								show error:RSUB can not have operand;
								continue;
							}
						}
						if(first token is mnemonic){
							record first token as this line mnemonic;
							record this line opcode from opcode;
							if(second token contains ","){//index addressing
								record this line is index addressing;
								second token cut by ",";
								if(not "X" after ","){
									error number added;
									show error:index wrong;
								}
								add second token as this line operand;
								if(second token not found in symbol table){
									//add new symbol without address
									record second token as symbol label
									add symbol into symbol table; 
								}else {
									record symbol code from symbol table + 8000 as this line symbol code;
								}
								this line add into ouput list;
								current address added by 3;
							}else{// not index addressing
								if(second token not found in symbol table){
									//add new symbol without address
									record second token as symbol label
									add symbol into symbol table; 
								}else {
									record symbol code from symbol table as this line symbol code;
								}
								add this line into output list;
								current address added by 3);
							}//--------------------------- check until here ----------------------------------
						}else if(second token is "RSUB"){
							if(first token not found in symbol table){
								add new symbol and define address by current address;
							}else if(first token found in symbol table without address){
								define symbol address by current address;
								//fill up
							}else{
								error number added;
								show error:cannot define symbol more than once;
							}
							add output;
							current address + 3;

						}else if(first token is notmne){
							error number added;
							show error:notmne cannot without label;
						}else if(first token is "END"){
							if(second token not found in symbol table){
								error number added;
								show error:undefined symbol behind END;
								record program ended;
							}else{
								add this line into ouput table;
								record current address as ending address;
								record program ended;
							}
						}else if(first token is mnemonic and is notmne){
							error number added;
							show error:mnemonic wrong;

						}else {//prevent unknown error
							error number added;
							show error:format wrong;
						}
					}else if(has 3 token){
						if(second token is "RSUB"){
							if(third token not space and tab){
								error number added;
								show error:RSUB can not have operand);
								break;//continue
							}
						}
						if(first token is mnemonic){
							if(second token contains ","){
								second token cut by ",";
								if(third token not "X"){
									error number added;
									show error:index wrong;
								}
								if(second token not found in symbol table){
									add new symbol without address;
								}else{
									symbol code + 8000;
								}
								add output;
								current address + 3;
							}else{//prevent unknown error;
								error number added;
								show error:format wrong;
							}
						}else if(second token is mnemonic){
							if(first token is mnemonic or notmne){
								error number added;
								show error:symbol cannot same with mnemonic;
							}else{
								if(first token not found in symbol table){
									add new symbol with address;
								}else if(first token found in symbol table without address){
									add current address as symbol address;
									//fill up symbol code 
									for(check output list){
										if(output symbol code is null && output operand same with first token){
											add symbol address as output symbol code; 
										}
									}
								}else{
									error number added;
									show error: cannot define symbol more than once;
								}
								if(third token not found in symbol table){
									add new symbol without address;
								}else{
									get symbol code from symbol table;
								}
								add output;
								current address + 3;
							}
						}else if(second token is notmne){
							if(first token is mnemonic or notmne){
								error number added;
								show error:symbol cannot same with mnemonic;
							}else{
								if(first token not found in symbol table){
									add new symbol with address;
								}else if(first token found in symbol table without address){
									add current address as symbol address;
									for(check output list){
										if(output symbol code == null and output operand same with first token){
											add symbol address as output symbol code; 
										}
									}
								}else{
									error number added;
									show error: cannot define symbol more than once;
								
								}
								if(second token is "BYTE"){
									third token cut by ("'");
									if(no words behind "'"){
										error number added;
										show error:byte value cannot be empty;
									}else{
										if("C" before "'"){
											for(words in "'"){
												translate to 16 digits and save as symbol code;
											}
											current address + length of 16 digits;
											
										}else if("X" before "'"){
											if(length of word in "'" cannot be mod 2){
												error number added;
												show error:byte X value length cannot be odd number;
											}else{
												if(word in "'" is 16 digits){
													add 16 digits as symbol code;
													current address + 1;		
												}else{
													error number added;
													show error:BYTE X value allow 16 digits;
												}
												
											}
										}else {
											error number added;
											show error:value type of BYTE only allow C and X;
										}
									}

								}else if(second token is "RESB"){
									if(third token not number){
										error number added;
										show error:RESB value only allow decimal;
									}else{
										current address + RESB value;
									}
								}else if(second token is "WORD"){
									if(third token not number){
										error number added;
										show error:only allow decimal;
									}else{
										translate value of WORD to 16 digits;
										add 16 digits as symbol code;
										current address + 3;
									}

								}else if(second token is "RESW"){
									if(third token not number){
										error number added;
										show error:only allow decimal;
									}else{
										current address + value of RESW * 3;
									}
								}
								
								add output;
							}
						}else if(second token not mnemonic and notmne){
							error number added;
							show error:mnemonic wrong;

						}else {
							error number added;
							show error:format wrong;
						}
					}
					
				}
			}else {//token more than 3
				error number added;
				show error:token more than 3;
			}
		}
		
	}
	//output
}